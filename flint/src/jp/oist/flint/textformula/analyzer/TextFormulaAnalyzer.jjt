
options {
    DEBUG_PARSER = false;
    STATIC = false;
    MULTI=true;
    VISITOR = true;
    VISITOR_EXCEPTION = "ParseException";
    NODE_EXTENDS="jp.oist.flint.textformula.node.TextFormulaNode";
}

PARSER_BEGIN(TextFormulaAnalyzer)

package jp.oist.flint.textformula.analyzer;

import jp.oist.flint.textformula.TextFormulaAnalyzerDefaultVisitor;

public class TextFormulaAnalyzer {

    private TextFormulaAnalyzerVisitor visitor = 
        new TextFormulaAnalyzerDefaultVisitor();

    private SimpleNode node = null;

    public TextFormulaAnalyzer() {
        this(new java.io.StringReader(""));
    }

    public void dump (String prefix) {
        if (node == null) return;
        node.dump(prefix);
    }

    public void dump () {
        if (node == null) return;
        node.dump("");
    }

    public void analyze () throws ParseException {
        node = this._Analyze();
        node.jjtAccept(this.visitor, null);
    }

    public void analyze (java.io.Reader reader) throws ParseException {
        ReInit(reader);
        this.analyze();
    }

    public void analyze (java.io.InputStream stream) throws ParseException {
        this.analyze(stream, null);
    }

    public void analyze (java.io.InputStream stream, String encoding) 
            throws ParseException {
        ReInit(stream, encoding);
        analyze();
    }

    public void setVisitor (TextFormulaAnalyzerVisitor visitor) {
        this.visitor = visitor;
    }

    public TextFormulaAnalyzerVisitor getVisitor() {
        return this.visitor;
    }
}

PARSER_END(TextFormulaAnalyzer)

SKIP : { /* white space */
  " "
| "\t"
| "\n"
| "\r"
| "\r\n"
| "\f"
}

TOKEN :  /* identifiers */ 
{
  <#DIGIT: ["0"-"9"]>
| <#LETTER:["a"-"z", "A"-"Z", "_"]>
| <#EXPONENT: ["e","E"]>
}

TOKEN : /* separators */
{
  < LBRACKET: "(" >
| < RBRACKET: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < COMMA: "," >
| <#DOT: "." > 
}
 /* operators */
TOKEN :
{
  < PLUS:   "+" >
| < MINUS:  "-" >
| < TIMES:  "*" >
| < DIVIDE: "/" >
//| < REM:    "%" >
}

TOKEN : /* values */
/*
   Floating Literal
   ex) 123E1 or 123e1
       123E-45 or 123e+45
       123.4E or 123.4e, 123.4
       123.4E-56 or 123.4e+56
       .1E or .1e, .1
       .1E-23 or .1e+23
 */
{
  <DECIMAL_LITERAL: (<DIGIT>)* (<DOT>)? (<DIGIT>)+ (<EXPONENT> (["+", "-"])? (<DIGIT>)+)? >
| <IDENTIFIER: (<LETTER>)+(<LETTER>|<DIGIT>)*>
}

/* Expression Rule */
SimpleNode _Analyze():
{
    String name;
}
{
    LOOKAHEAD(3) Expression() <EOF> { 
        return jjtThis; 
    }
|   Identifier() "=" Expression() <EOF> #AssignmentNode(2) {
        return jjtThis;
    }
}

void Expression ():
{}
{
    ConditionalExpression() 
}

void ConditionalExpression () #void:
{}
{
    EqualityExpression() ( 
        "||" EqualityExpression() #OrNode(2) 
|       "&&" EqualityExpression() #AndNode(2) 
    )*
}


void EqualityExpression () #void:
{}
{
    RelationalExpression() (
        "==" RelationalExpression()    #EQNode(2)
|       "!=" RelationalExpression()    #NENode(2)
    )* 
}

void RelationalExpression() #void:
{}
{
    AdditiveExpression() (
        "<"  AdditiveExpression()  #LTNode(2)
|       ">"  AdditiveExpression()  #GTNode(2)
|       "<=" AdditiveExpression()  #LENode(2)
|       ">=" AdditiveExpression()  #GENode(2)
    )*
}

void AdditiveExpression() #void:
{}
{
    MultiveExpression () (
        "+" MultiveExpression() #AddNode(2)
|       "-" MultiveExpression() #SubsNode(2) {
        }
    )*
}

void MultiveExpression() #void:
{}
{
    SimpleExpression () (
        "*" SimpleExpression() #MultNode(2)
|       "/" SimpleExpression() #DivNode(2)
//|       "%" SimpleExpression() #ModNode(2)
    )*
}


void SimpleExpression() #void:
{}
{

   // Positive Expression
    Number()
|   Variable()
|   LOOKAHEAD(2) Matrix()
|   Vector()
|   "(" Expression() ")"

   // Nagative Expression
|  LOOKAHEAD(2) "-" Number()    #SubsNode(1)
|  LOOKAHEAD(3) "-" Variable()  #SubsNode(1)
|  LOOKAHEAD(3) "-" Vector()    #SubsNode(1)
|  LOOKAHEAD(3) "-" Matrix()    #SubsNode(1)
|  "-"  "(" Expression() ")"    #SubsNode(1)
}

int ArgumentList () #void:
{ int argc=0; }
{
    Expression() {argc++;}  ("," Expression() {argc++;})* {
        return argc;
    }
}

void Number ():
{ Token t; }
{
    t=<DECIMAL_LITERAL> {
        Double.parseDouble(t.image);
        jjtThis.value = t.image;
    }
}

void Variable () #void:
{}
{
    LOOKAHEAD(3) Function()
|   Identifier()
}

void Function ():
{Token t; int argc=0;}
{
    t=<IDENTIFIER> "(" argc=ArgumentList() ")" {
        jjtThis.numberOfArguments = argc;
        jjtThis.value = t.image;
        jjtThis.type = "Function";
    }
}

String Identifier ():
{ Token t; }
{
    t=<IDENTIFIER> {
        jjtThis.value = t.image;
        return t.image;
    }
}

int Vector (): 
{ int argc=0; }
{
    "{" argc=ArgumentList() "}" {
        jjtThis.numberOfArguments = argc;
        return argc;
    }
}

int VectorList (): 
{ int argc=0; }
{
    Vector() { argc++; } ("," Vector() { argc++; })* {}  {
        jjtThis.numberOfArguments = argc;
        return argc;
    }
}

void Matrix ():
{ int argc=0; }
{
    "{" argc=VectorList() "}" {
        jjtThis.numberOfArguments = argc;
    }
}

